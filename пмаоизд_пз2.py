# -*- coding: utf-8 -*-
"""ПМАОиЗД_ПЗ2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18erz_ICZwIWhLykCXuqwPbsPcb_rEve3
"""

# Установка необходимых библиотек
!pip install pulp

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import linprog
import pulp

print("=" * 60)
print("ЗАДАЧА 5: F = x₁ + 2x₂ → min/max")
print("=" * 60)

# Коэффициенты целевой функции
c_min = [1, 2]  # для минимизации
c_max = [-1, -2]  # для максимизации

# Матрица ограничений A*x <= b
A = [[1, 1],
     [2, 1],
     [1, 0]]

b = [4, 6, 3]

# Границы переменных
bounds = [(0, None), (0, None)]

### 1. Решение с использованием SciPy
print("\n1. РЕШЕНИЕ С ИСПОЛЬЗОВАНИЕМ SCIPY")
print("-" * 40)

# Минимизация
result_min = linprog(c_min, A_ub=A, b_ub=b, bounds=bounds, method='highs')
print("МИНИМИЗАЦИЯ:")
print(f"Оптимальное решение: x₁ = {result_min.x[0]:.2f}, x₂ = {result_min.x[1]:.2f}")
print(f"Минимальное значение F = {result_min.fun:.2f}")
print(f"Статус: {result_min.message}")

# Максимизация
result_max = linprog(c_max, A_ub=A, b_ub=b, bounds=bounds, method='highs')
print("\nМАКСИМИЗАЦИЯ:")
print(f"Оптимальное решение: x₁ = {result_max.x[0]:.2f}, x₂ = {result_max.x[1]:.2f}")
print(f"Максимальное значение F = {-result_max.fun:.2f}")
print(f"Статус: {result_max.message}")

### 2. Решение с использованием PuLP
print("\n2. РЕШЕНИЕ С ИСПОЛЬЗОВАНИЕМ PULP")
print("-" * 40)

# Минимизация
prob_min = pulp.LpProblem("Minimization", pulp.LpMinimize)
x1 = pulp.LpVariable('x1', lowBound=0)
x2 = pulp.LpVariable('x2', lowBound=0)

prob_min += x1 + 2*x2, "Objective"
prob_min += x1 + x2 <= 4, "Constraint1"
prob_min += 2*x1 + x2 <= 6, "Constraint2"
prob_min += x1 <= 3, "Constraint3"

prob_min.solve()

print("МИНИМИЗАЦИЯ:")
print(f"Оптимальное решение: x₁ = {x1.value():.2f}, x₂ = {x2.value():.2f}")
print(f"Минимальное значение F = {pulp.value(prob_min.objective):.2f}")
print(f"Статус: {pulp.LpStatus[prob_min.status]}")

# Максимизация
prob_max = pulp.LpProblem("Maximization", pulp.LpMaximize)
x1_max = pulp.LpVariable('x1_max', lowBound=0)
x2_max = pulp.LpVariable('x2_max', lowBound=0)

prob_max += x1_max + 2*x2_max, "Objective"
prob_max += x1_max + x2_max <= 4, "Constraint1"
prob_max += 2*x1_max + x2_max <= 6, "Constraint2"
prob_max += x1_max <= 3, "Constraint3"

prob_max.solve()

print("\nМАКСИМИЗАЦИЯ:")
print(f"Оптимальное решение: x₁ = {x1_max.value():.2f}, x₂ = {x2_max.value():.2f}")
print(f"Максимальное значение F = {pulp.value(prob_max.objective):.2f}")
print(f"Статус: {pulp.LpStatus[prob_max.status]}")

### 3. Графическое решение
print("\n3. ГРАФИЧЕСКОЕ РЕШЕНИЕ")
print("-" * 40)

# Создаем график
fig, ax = plt.subplots(figsize=(12, 10))

# Определяем область построения
x = np.linspace(0, 4, 400)

# Строим ограничения
# 1) x₁ + x₂ ≤ 4 → x₂ ≤ 4 - x₁
y1 = 4 - x
ax.plot(x, y1, 'r-', label='x₁ + x₂ ≤ 4', linewidth=2)

# 2) 2x₁ + x₂ ≤ 6 → x₂ ≤ 6 - 2x₁
y2 = 6 - 2*x
ax.plot(x, y2, 'b-', label='2x₁ + x₂ ≤ 6', linewidth=2)

# 3) x₁ ≤ 3
ax.axvline(x=3, color='g', linestyle='-', label='x₁ ≤ 3', linewidth=2)

# Оси
ax.axhline(y=0, color='k', linestyle='-', alpha=0.3)
ax.axvline(x=0, color='k', linestyle='-', alpha=0.3)

# Правильно находим вершины многоугольника
vertices = []

# 1. Начало координат (0, 0)
vertices.append((0, 0))

# 2. Пересечение оси x₁ с x₁ = 3
vertices.append((3, 0))

# 3. Пересечение x₁ = 3 и x₁ + x₂ = 4
# x₁ = 3, тогда 3 + x₂ = 4 → x₂ = 1
vertices.append((3, 1))

# 4. Пересечение x₁ + x₂ = 4 и 2x₁ + x₂ = 6
# Решаем систему:
# x₁ + x₂ = 4
# 2x₁ + x₂ = 6
# Вычитаем первое из второго: x₁ = 2, тогда 2 + x₂ = 4 → x₂ = 2
vertices.append((2, 2))

# 5. Пересечение 2x₁ + x₂ = 6 с осью x₂ (x₁ = 0)
# 0 + x₂ = 6 → x₂ = 6
vertices.append((0, 6))

# 6. Пересечение x₁ + x₂ = 4 с осью x₂ (x₁ = 0)
# 0 + x₂ = 4 → x₂ = 4
vertices.append((0, 4))

# Фильтруем вершины, принадлежащие допустимой области
feasible_vertices = []
for v in vertices:
    x1_val, x2_val = v
    # Проверяем все ограничения
    if (x1_val >= 0 and x2_val >= 0 and
        x1_val + x2_val <= 4 + 1e-6 and
        2*x1_val + x2_val <= 6 + 1e-6 and
        x1_val <= 3 + 1e-6):
        feasible_vertices.append(v)

# Убираем дубликаты
feasible_vertices = list(set(feasible_vertices))
feasible_vertices.sort()

print("Найденные вершины допустимой области:")
for i, v in enumerate(feasible_vertices):
    print(f"Вершина {i+1}: {v}")

# Заполняем область
if len(feasible_vertices) >= 3:
    # Сортируем вершины для правильного построения многоугольника
    center_x = sum(v[0] for v in feasible_vertices) / len(feasible_vertices)
    center_y = sum(v[1] for v in feasible_vertices) / len(feasible_vertices)

    def angle_from_center(vertex):
        return np.arctan2(vertex[1] - center_y, vertex[0] - center_x)

    poly_vertices = sorted(feasible_vertices, key=angle_from_center)
else:
    poly_vertices = feasible_vertices

poly = plt.Polygon(poly_vertices, alpha=0.3, color='lightblue', label='Допустимая область')
ax.add_patch(poly)

# Отмечаем вершины и вычисляем значения F
print("\nВершины допустимой области и значения F:")
F_values = []
for i, vertex in enumerate(feasible_vertices):
    x1_val, x2_val = vertex
    F_val = x1_val + 2*x2_val
    F_values.append(F_val)
    ax.plot(x1_val, x2_val, 'ro', markersize=8)
    ax.annotate(f'({x1_val},{x2_val})\nF={F_val}',
               (x1_val, x2_val),
               xytext=(5, 5),
               textcoords='offset points',
               fontsize=10,
               bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.7))
    print(f"Вершина {i+1}: ({x1_val}, {x2_val}) → F = {F_val}")

# Находим оптимальные точки
min_index = np.argmin(F_values)
max_index = np.argmax(F_values)

min_point = feasible_vertices[min_index]
max_point = feasible_vertices[max_index]

print(f"\nОПТИМАЛЬНЫЕ РЕШЕНИЯ:")
print(f"Минимум F: F({min_point[0]}, {min_point[1]}) = {F_values[min_index]}")
print(f"Максимум F: F({max_point[0]}, {max_point[1]}) = {F_values[max_index]}")

# Отмечаем оптимальные точки
ax.plot(min_point[0], min_point[1], 'go', markersize=12, label=f'Min F={F_values[min_index]:.1f}')
ax.plot(max_point[0], max_point[1], 'mo', markersize=12, label=f'Max F={F_values[max_index]:.1f}')

# Добавляем линии уровня для визуализации
x1_range = np.linspace(0, 3.5, 100)
x2_range = np.linspace(0, 4.5, 100)
X1, X2 = np.meshgrid(x1_range, x2_range)
F = X1 + 2*X2

# Показываем несколько линий уровня
levels = [F_values[min_index], F_values[max_index],
          (F_values[min_index] + F_values[max_index])/2]
CS = ax.contour(X1, X2, F, levels=levels, colors='gray', linestyles='dashed', alpha=0.7)
ax.clabel(CS, inline=True, fontsize=10)

# Настройки графика
ax.set_xlabel('x₁', fontsize=12)
ax.set_ylabel('x₂', fontsize=12)
ax.set_title('Графическое решение задачи: F = x₁ + 2x₂ → min/max', fontsize=14)
ax.legend(fontsize=10)
ax.grid(True, alpha=0.3)
ax.set_xlim(0, 3.5)
ax.set_ylim(0, 4.5)
ax.set_aspect('equal')

plt.tight_layout()
plt.show()

print("\n" + "=" * 60)
print("ОТВЕТ ДЛЯ ЗАДАЧИ 5:")
print(f"F min = F({min_point[0]}, {min_point[1]}) = {F_values[min_index]}")
print(f"F max = F({max_point[0]}, {max_point[1]}) = {F_values[max_index]}")
print("=" * 60)